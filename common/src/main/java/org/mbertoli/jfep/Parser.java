/**
 * Copyright 2006 Bertoli Marco
 * <p>
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.mbertoli.jfep;

import java.util.HashSet;

/**
 * <p><b>Name:</b> Parser</p>
 * <p><b>Description:</b>
 * Simple Java arithmetic expression parser and ELL(1) grammar syntactical analizer and evaluator.
 * Parser supports detection of implicit multiplication when a constant is followed by a variable or function.
 * </p>
 * <p><b>Grammar:</b><br>
 * S -&gt; E (('+' | '-') E)*<br>
 * E -&gt; G ('*' G)*<br>
 * G -&gt; H ('/' H)*<br>
 * H -&gt; T ('%' T)*<br>
 * T -&gt; F | '-' F<br>
 * F -&gt; U ('^' U)*<br>
 * U -&gt; function '(' S ')' | number | '(' S ')' | variable<br>
 * </p>
 * <p><b>Date:</b> 08/dic/06
 * <b>Time:</b> 13:58:28</p>
 *
 * @author Bertoli Marco
 * @version 1.0
 */
public class Parser {

  private static final char CL_BRACKET = ')'; // closed bracket

  private static final char FUNC = 'f'; // function

  private static final char NUM = 'n'; // number

  private static final char OP_BRACKET = '('; // open bracket

  // Special tokens
  private static final char TERM = '@'; // Input end character

  private static final char VAR = 'x'; // variable

  private final boolean error;

  private final HashSet functions; // Used functions

  private final char[] input;

  private final HashSet variables; // Used variables

  private Element cc; // Current character

  private int inp_cur; // Current input position

  private ExpressionNode root; // Root of expression tree

  /**
   * Class constructor
   *
   * @param str Input string to be analyzed
   */
  public Parser(final String str) {
    this(str, false);
  }

  /**
   * Class constructor
   *
   * @param str Input string to be analyzed
   * @param error if true, an exception is raised when value is get
   *   from a variable not initialized. If false, that variable is
   *   considered as zero.
   */
  public Parser(final String str, final boolean error) {
    this.input = this.convertInput(str);
    this.root = null;
    this.inp_cur = 0;
    this.error = error;
    this.functions = new HashSet();
    this.variables = new HashSet();
  }

  /**
   * Returns a string rappresentation of parsed expression with the right parentesis
   *
   * @return a string rappresentation of parsed expression with the right parentesis
   *
   * @throws ParseError if parsed input string was malformed
   */
  public String getExpression() throws ParseError {
    this.getTree();
    return this.root.toString();
  }

  /**
   * Returns input string, without invalid characters
   *
   * @return input string without invalid characters
   */
  public String getInputString() {
    final StringBuffer output = new StringBuffer();
    for (int i = 0; i < this.input.length && this.input[i] != Parser.TERM; i++) {
      output.append(this.input[i]);
    }
    return output.toString();
  }

  /**
   * Returns a Set of all functions parsed in input string
   *
   * @return a set with all parsed functions
   *
   * @throws ParseError if parsed input string was malformed
   */
  public HashSet getParsedFunctions() throws ParseError {
    this.getTree();
    return this.functions;
  }

  /**
   * Returns a Set of all variables parsed in input string
   *
   * @return a set with all parsed variables
   *
   * @throws ParseError if parsed input string was malformed
   */
  public HashSet getParsedVariables() throws ParseError {
    this.getTree();
    return this.variables;
  }

  /**
   * Returns the tree of the function generated by the parser
   *
   * @return Node root node of parsed tree
   *
   * @throws ParseError if parsed input string was malformed
   */
  public ExpressionNode getTree() throws ParseError {
    if (this.root == null) { // Function need parsing
      this.cc = this.parse();
      this.root = this.S();
      if (!this.isEndOfExpression(this.cc.getToken())) {
        throw new ParseError("Expecting operator or end of input", this.inp_cur);
      }
      return this.root;
    } else {
      return this.root; // Parsing was already performed before
    }
  }

  /**
   * Returns the value for evaluated expression
   *
   * @return value of expression
   *
   * @throws ParseError if parsed input string was malformed
   * @throws EvaluationException if one variable was not initialized and parser was
   *   created with <code>error = true</code>
   * @see #Parser(String, boolean)
   */
  public double getValue() throws ParseError, EvaluationException {
    this.getTree();
    return this.root.getValue();
  }

  /**
   * Sets the value for a given variable
   *
   * @param name name of the variable to be set (case sensitive)
   * @param value value for the variable
   *
   * @throws ParseError if parsed input string was malformed
   */
  public void setVariable(final String name, final double value) throws ParseError {
    this.getTree();
    this.root.setVariable(name, value);
  }

  /**
   * Converts input string in a character array and removes unsupported characters
   *
   * @param str input string
   *
   * @return converted string, terminated by TERM character
   */
  protected char[] convertInput(final String str) {
    final char[] input = str.toCharArray();
    final char[] output = new char[input.length + 1]; // One more space for terminator
    int pos = 0; // Position on output
    for (int i = 0; i < input.length; i++) {
      final char c = input[i];
      if (this.isNumber(c) || this.isOperator(c) || this.isText(c) || this.isBracket(c)) {
        output[pos++] = c;
      }
    }
    output[pos++] = Parser.TERM;
    return output;
  }

  /**
   * Non-terminal E<br>
   * E -&gt; G ('*' G)*<br>
   *
   * @return Node
   */
  private ExpressionNode E() {
    ExpressionNode current = this.G();
    while (this.cc.getToken() == '*') {
      this.cc = this.parse();
      current = new OperatorNode(current, this.G(), '*');
    }
    return current;
  }

  /**
   * Non-terminal F<br>
   * F -&gt; U ('^' U)*
   *
   * @return Node
   */
  private ExpressionNode F() {
    final ExpressionNode left;
    left = this.U();
    if (this.cc.getToken() == '^') {
      this.cc = this.parse();
      return new OperatorNode(left, this.F(), '^');
    }
    return left;
  }

  /**
   * Non-terminal G<br>
   * G -&gt; H ('/' H)*<br>
   *
   * @return Node
   */
  private ExpressionNode G() {
    ExpressionNode current = this.H();
    while (this.cc.getToken() == '/') {
      this.cc = this.parse();
      current = new OperatorNode(current, this.H(), '/');
    }
    return current;
  }

  /**
   * Non-terminal H<br>
   * H -&gt; T ('%' T)*<br>
   *
   * @return Node
   */
  private ExpressionNode H() {
    ExpressionNode current = this.T();
    while (this.cc.getToken() == '%') {
      this.cc = this.parse();
      current = new OperatorNode(current, this.T(), '%');
    }
    return current;
  }

  /**
   * Grammar Axiom S<br>
   * S -&gt; E (('+' | '-') E)*
   *
   * @return Node
   */
  private ExpressionNode S() {
    ExpressionNode current = this.E();
    while (this.cc.getToken() == '+' || this.cc.getToken() == '-') {
      final char operator = this.cc.getToken();
      this.cc = this.parse();
      current = new OperatorNode(current, this.E(), operator);
    }
    return current;
  }

  /**
   * Non-terminal T<br>
   * T -&gt; F | '-' F<br>
   *
   * @return Node
   */
  private ExpressionNode T() {
    if (this.cc.getToken() == '-') {
      this.cc = this.parse();
      return new FunctionNode(this.F(), "-");
    }
    return this.F();
  }

  /**
   * Non-terminal U<br>
   * U -&gt; function '(' S ')' | number | '(' S ')' | variable
   *
   * @return Node
   */
  private ExpressionNode U() {
    switch (this.cc.getToken()) {
      case Parser.NUM:
        final double n = this.cc.number;
        final int constPosition = this.cc.position; // Position if this is a built-in constant
        this.cc = this.parse();
        if (constPosition >= 0) {
          return new ConstantNode(constPosition);
        } else {
          return new ConstantNode(n);
        }
      case Parser.VAR:
        final String name = this.cc.name;
        this.cc = this.parse();
        return new VariableNode(name, this.error);
      case Parser.OP_BRACKET:
        this.cc = this.parse();
        final ExpressionNode tmp = this.S();
        if (this.cc.getToken() == Parser.CL_BRACKET) {
          this.cc = this.parse();
          return tmp;
        }
        throw new ParseError("Semantic Error, expected '" + Parser.CL_BRACKET + "'", this.inp_cur);
      case Parser.FUNC:
        final int function = this.cc.position;
        this.cc = this.parse();
        if (this.cc.getToken() == Parser.OP_BRACKET) {
          this.cc = this.parse();
        } else {
          throw new ParseError("Semantic Error, expected '" + Parser.OP_BRACKET + "'", this.inp_cur);
        }
        final ExpressionNode tmp2 = this.S();
        if (this.cc.getToken() == Parser.CL_BRACKET) {
          this.cc = this.parse();
        } else {
          throw new ParseError("Semantic Error, expected '" + Parser.CL_BRACKET + "'", this.inp_cur);
        }
        return new FunctionNode(tmp2, function);
    }
    throw new ParseError("Semantic Error, expected function or variable or constant or '('", this.inp_cur);
  }

  /**
   * Helper method to detect implicit multiplication
   *
   * @return true only if inplicit multiplication is detected
   */
  private boolean detectImplicitMult() {
    if (this.cc != null && this.cc.getToken() == Parser.NUM) {
      this.cc = null; // Otherwise we will loop forever
      // Stores old pointer to restore it back
      final int old_input = this.inp_cur;
      final Element next = this.parse();
      // Restores old pointer back
      this.inp_cur = old_input;
      return next.getToken() == Parser.VAR || next.getToken() == Parser.FUNC;
    }
    return false;
  }

  /**
   * Returns if input character is a bracket
   *
   * @param c character
   *
   * @return truth value
   */
  private boolean isBracket(final char c) {
    return c == Parser.OP_BRACKET || c == Parser.CL_BRACKET;
  }

  /**
   * Returns if imput character is the last one (TERM)
   *
   * @param c input character
   *
   * @return truth value
   */
  private boolean isEndOfExpression(final char c) {
    return c == Parser.TERM;
  }

  /**
   * Returns if input character is a number
   *
   * @param c input character
   *
   * @return truth value
   */
  private boolean isNumber(final char c) {
    return c >= '0' && c <= '9' || c == '.';
  }

  /**
   * Returns if imput character character is an operator
   *
   * @param c input character
   *
   * @return truth value
   */
  private boolean isOperator(final char c) {
    for (int i = 0; i < OperatorNode.OPERATIONS.length; i++) {
      if (c == OperatorNode.OPERATIONS[i]) {
        return true;
      }
    }
    return false;
  }

  /**
   * Returns if input character is valid text
   *
   * @param c input character
   *
   * @return truth value
   */
  private boolean isText(final char c) {
    return c >= 'A' && c <= 'Z' ||
      c >= 'a' && c <= 'z' ||
      c == '_';
  }

  /**
   * Perform parsing of input string
   *
   * @return Element
   */
  private Element parse() {
    // Detects implicit multiplication
    if (this.detectImplicitMult()) {
      return new Element('*');
    }
    // Matches operators, brackets and termination character
    if (this.isOperator(this.input[this.inp_cur]) || this.isBracket(this.input[this.inp_cur]) || this.isEndOfExpression(this.input[this.inp_cur])) {
      return new Element(this.input[this.inp_cur++]);
    }
    // Matches numbers
    if (this.isNumber(this.input[this.inp_cur])) {
      final int tmp = this.inp_cur++;
      // Finds the end of number
      while (this.isNumber(this.input[this.inp_cur])) {
        this.inp_cur++;
      }
      // Eventual exponential
      if (Character.toLowerCase(this.input[this.inp_cur]) == 'e') {
        if (this.input[this.inp_cur + 1] == '-' || this.isNumber(this.input[this.inp_cur + 1])) {
          this.inp_cur += 2;
        }
        while (this.isNumber(this.input[this.inp_cur])) {
          this.inp_cur++;
        }
      }
      final String s = new String(this.input, tmp, this.inp_cur - tmp);
      final double d;
      try {
        d = Double.valueOf(s).doubleValue();
      } catch (final NumberFormatException ex) {
        throw new ParseError("Invalid number: " + s, this.inp_cur);
      }
      return new Element(Parser.NUM, d);
    }
    // Matches text (functions or variables or built-in constants)
    if (this.isText(this.input[this.inp_cur])) {
      final int tmp = this.inp_cur++;
      // Finds the end of text
      while (this.isText(this.input[this.inp_cur]) || this.isNumber(this.input[this.inp_cur])) {
        this.inp_cur++;
      }
      final String s = new String(this.input, tmp, this.inp_cur - tmp);
      final String lower = s.toLowerCase();
      // Now searches if this string is a function
      for (int i = 0; i < FunctionNode.FUNCTIONS.length; i++) {
        if (lower.equals(FunctionNode.FUNCTIONS[i])) {
          this.functions.add(FunctionNode.FUNCTIONS[i]);
          return new Element(Parser.FUNC, i);
        }
      }
      // Now searches if this string is a built-in constant
      for (int i = 0; i < ConstantNode.CONSTANTS.length; i++) {
        if (lower.equals(ConstantNode.CONSTANTS[i])) {
          return new Element(Parser.NUM, i);
        }
      }
      // String was not a function, so treat it as a variable
      this.variables.add(s);
      return new Element(Parser.VAR, s);
    }
    //At this point everything not recognized is an error
    throw new ParseError("Unrecognized identifier", this.inp_cur);
  }

  /**
   * Data structure used internally to return parsed elements.
   */
  private class Element {

    private final char token;

    public String name = null;

    public double number = Double.NaN;

    public int position = -1;

    public Element(final char token) {
      this.token = token;
    }

    public Element(final char token, final double number) {
      this.token = token;
      this.number = number;
    }

    public Element(final char token, final String name) {
      this.token = token;
      this.name = name;
    }

    public Element(final char token, final int position) {
      this.token = token;
      this.position = position;
    }

    /**
     * Returns the token
     *
     * @return char
     */
    public char getToken() {
      return this.token;
    }
  }
}
